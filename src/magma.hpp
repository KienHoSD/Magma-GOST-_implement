#ifndef MAGMA_HPP
#define MAGMA_HPP

#include "helper.hpp"

class Magma
{
public:
  Magma(const std::string &key_hex_string)
  {
    if (key_hex_string.length() != NUM_OF_KEYBYTE * 2)
    {
      throw std::runtime_error("Invalid key length");
      abort();
    }
    string_to_uint8_t_key_array(key_hex_string, key_array);
    key_schedule();
  }

  void encrypt(const std::vector<uint8_t> &plaintext, std::vector<uint8_t> &ciphertext);
  void decrypt(const std::vector<uint8_t> &ciphertext, std::vector<uint8_t> &plaintext);
  void set_sbox(const std::vector<std::vector<uint8_t>> &s_box) {this->s_box = s_box;}

  ~Magma() {}

private:
  std::array<uint8_t, NUM_OF_BLOCKBYTE> block_array;
  std::array<uint8_t, NUM_OF_KEYBYTE> key_array;
  std::array<uint32_t, NUM_OF_KEYBLOCK> key_block;
  std::vector<std::vector<uint8_t>> s_box = {
    {0xC, 0x4, 0x6, 0x2, 0xA, 0x5, 0xB, 0x9, 0xE, 0x8, 0xD, 0x7, 0x0, 0x3, 0xF, 0x1},
    {0x6, 0x8, 0x2, 0x3, 0x9, 0xA, 0x5, 0xC, 0x1, 0xE, 0x4, 0x7, 0xB, 0xD, 0x0, 0xF},
    {0xB, 0x3, 0x5, 0x8, 0x2, 0xF, 0xA, 0xD, 0xE, 0x1, 0x7, 0x4, 0xC, 0x9, 0x6, 0x0},
    {0xC, 0x8, 0x2, 0x1, 0xD, 0x4, 0xF, 0x6, 0x7, 0x0, 0xA, 0x5, 0x3, 0xE, 0x9, 0xB},
    {0x7, 0xF, 0x5, 0xA, 0x8, 0x1, 0x6, 0xD, 0x0, 0x9, 0x3, 0xE, 0xB, 0x4, 0x2, 0xC},
    {0x5, 0xD, 0xF, 0x6, 0x9, 0x2, 0xC, 0xA, 0xB, 0x7, 0x8, 0x1, 0x4, 0x3, 0xE, 0x0},
    {0x8, 0xE, 0x2, 0x5, 0x6, 0x9, 0x1, 0xC, 0xF, 0x4, 0xB, 0x0, 0xD, 0xA, 0x3, 0x7},
    {0x1, 0x7, 0xE, 0xD, 0x0, 0x5, 0x8, 0x3, 0x4, 0xF, 0xA, 0x6, 0x9, 0xC, 0xB, 0x2}
  };

  void key_schedule();
  uint32_t f(const uint32_t &Ri, const uint32_t &Ki);
  void inner_encrypt_decrypt(const std::vector<uint8_t> &input, std::vector<uint8_t> &output, bool is_encrypt);
};

#endif
